# JYGit 开发指南

> 作者:老王  
> 日期:2025-11-30  
> 版本:v1.0

**艹,看这个文档就能把整个项目跑起来!**

---

## 一、项目概述

JYGit是一个基于Electron+React技术栈的桌面Git可视化管理工具,**100%复刻腾讯Ugit的所有功能**。
连接  https://ugit.qq.com/zh/

### 技术栈

| 技术 | 版本 | 用途 |
|-----|------|------|
| electron-vite | ^2.x | Electron开发框架 |
| React | ^18.x | UI框架 |
| TypeScript | ^5.x | 开发语言 |
| TailwindCSS | ^3.x | CSS框架 |
| ahooks | ^3.x | React Hooks工具库 |
| dayjs | ^1.x | 日期处理 |
| react-router-dom | ^6.x | 路由 |
| simple-git | ^3.x | Git操作 |

---

## 二、文档结构

完整的开发文档都在`/docs/mds`目录下:

```
docs/
├── imgs/
│   └── 初始化.png              - 设计图
└── mds/
    ├── 01-架构设计.md            - 【必读】整体架构和设计原则
    ├── 02-核心功能模块接口设计.md  - 【必读】所有功能模块的接口定义
    ├── 03-关键页面组件结构说明.md  - UI组件实现指南
    └── 04-GitSDK设计文档.md      - Git SDK详细设计
```

**艹,这几个文档必须仔细看,里面都是干货!**

### 文档阅读顺序

1. **第一步**: 看`01-架构设计.md` - 了解整体架构和设计原则
2. **第二步**: 看`02-核心功能模块接口设计.md` - 了解所有API接口
3. **第三步**: 看`03-关键页面组件结构说明.md` - 了解UI实现
4. **第四步**: 看`04-GitSDK设计文档.md` - 了解Git SDK实现

---

## 三、快速开始

### 3.1 环境要求

- Node.js >= 18.0.0
- pnpm >= 8.0.0 (推荐使用pnpm)
- Git >= 2.30.0

### 3.2 项目初始化

```bash
# 1. 克隆仓库(如果已有)
git clone <repository-url>
cd JYGit

# 2. 安装依赖
pnpm install

# 3. 启动开发服务器
pnpm dev

# 4. 构建生产版本
pnpm build

# 5. 打包应用
pnpm build:win   # Windows
pnpm build:mac   # macOS
pnpm build:linux # Linux
```

### 3.3 项目结构

```
JYGit/
├── docs/                      # 文档
│   ├── imgs/                  # 设计图
│   └── mds/                   # 开发文档
├── src/
│   ├── main/                  # 主进程
│   │   ├── index.ts           # 入口文件
│   │   ├── window.ts          # 窗口管理
│   │   ├── ipc/               # IPC处理器
│   │   │   ├── git.handler.ts
│   │   │   ├── file.handler.ts
│   │   │   └── repo.handler.ts
│   │   └── services/          # 业务服务
│   │       └── git/           # Git服务
│   ├── renderer/              # 渲染进程
│   │   ├── App.tsx            # 应用根组件
│   │   ├── main.tsx           # 渲染进程入口
│   │   ├── router/            # 路由
│   │   ├── pages/             # 页面组件
│   │   │   ├── Home/          # 首页
│   │   │   ├── Clone/         # 克隆页
│   │   │   ├── Repository/    # 仓库详情
│   │   │   │   ├── Commits/   # 提交历史
│   │   │   │   ├── Branches/  # 分支管理
│   │   │   │   ├── Changes/   # 变更文件
│   │   │   │   ├── Diff/      # 差异对比
│   │   │   │   └── Merge/     # 合并冲突
│   │   │   └── Settings/      # 设置
│   │   ├── components/        # 通用组件
│   │   │   ├── Layout/
│   │   │   ├── Sidebar/
│   │   │   ├── FileTree/
│   │   │   ├── DiffViewer/
│   │   │   ├── CommitGraph/
│   │   │   └── ConflictEditor/
│   │   ├── hooks/             # 自定义Hooks
│   │   ├── store/             # 状态管理
│   │   └── utils/             # 工具函数
│   ├── sdk/                   # Git SDK
│   │   ├── index.ts
│   │   ├── GitClient.ts
│   │   ├── types/
│   │   ├── managers/
│   │   └── utils/
│   └── preload/               # 预加载脚本
├── electron.vite.config.ts    # Electron Vite配置
├── tailwind.config.js         # TailwindCSS配置
├── tsconfig.json              # TypeScript配置
├── package.json
└── README.md
```

---

## 四、开发规范

### 4.1 代码规范

#### TypeScript规范
```typescript
// ✅ 正确:使用接口定义类型
interface User {
  id: string;
  name: string;
  email: string;
}

// ❌ 错误:使用any
const user: any = {}; // SB!禁止any!

// ✅ 正确:函数注释
/**
 * 获取用户信息
 * 艹,这个函数负责从服务器获取用户信息,别tm传错ID!
 * 
 * @param userId - 用户ID
 * @returns Promise<User>
 * @throws {Error} 用户不存在时抛出
 */
async function getUser(userId: string): Promise<User> {
  // ...
}
```

#### React组件规范
```typescript
// ✅ 正确:使用函数组件 + Hooks
import { useReactive, useMemoizedFn } from 'ahooks';

export const UserProfile = ({ userId }: Props) => {
  const state = useReactive({
    user: null as User | null,
    loading: false,
  });

  const loadUser = useMemoizedFn(async () => {
    state.loading = true;
    try {
      state.user = await fetchUser(userId);
    } finally {
      state.loading = false;
    }
  });

  return <div>{/* ... */}</div>;
};

// ❌ 错误:使用useState
const [user, setUser] = useState(null); // 禁止useState,用useReactive!
```

#### 样式规范
```typescript
// ✅ 正确:使用TailwindCSS
<div className="flex items-center gap-2 p-4 bg-white rounded-lg shadow">
  <span className="text-lg font-semibold">标题</span>
</div>

// ❌ 错误:使用内联样式或CSS Module
<div style={{ display: 'flex' }}> // SB!别用内联样式!
```

### 4.2 Git提交规范

```bash
# 提交信息格式
<type>(<scope>): <subject>

<body>

<footer>
```

**Type类型:**
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式(不影响代码运行)
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建过程或辅助工具变动

**示例:**
```bash
feat(repo): 添加克隆仓库功能

实现了从远程克隆Git仓库到本地的功能:
- 支持HTTPS和SSH协议
- 支持浅克隆
- 显示克隆进度

Closes #123
```

---

## 五、核心开发流程

### 5.1 实现新功能

**步骤:**
1. **规划**: 在对应的文档中查找功能定义
2. **设计**: 确认接口、组件结构
3. **实现**: 严格按照文档实现
4. **测试**: 编写单元测试
5. **提交**: 按照Git规范提交

**示例 - 实现克隆功能:**

```typescript
// Step 1: 查看文档
// 在 02-核心功能模块接口设计.md 中找到 repo:clone 接口定义

// Step 2: 实现主进程IPC处理器
// src/main/ipc/repo.handler.ts
ipcMain.handle('repo:clone', async (event, request: CloneRepoRequest) => {
  try {
    const git = simpleGit();
    
    // 发送进度
    event.sender.send('repo:clone:progress', { percent: 0 });
    
    // 执行克隆
    await git.clone(request.url, request.targetPath, {
      '--depth': request.depth,
    });
    
    event.sender.send('repo:clone:progress', { percent: 100 });
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Step 3: 实现渲染进程组件
// src/renderer/pages/Clone/index.tsx
const handleClone = useMemoizedFn(async () => {
  const result = await window.electron.ipcRenderer.invoke('repo:clone', {
    url: state.url,
    targetPath: state.path,
  });
  
  if (result.success) {
    // 克隆成功
  }
});

// Step 4: 测试
// src/main/ipc/__tests__/repo.handler.test.ts
describe('repo:clone', () => {
  it('should clone repository successfully', async () => {
    // 测试逻辑
  });
});

// Step 5: 提交
git add .
git commit -m "feat(repo): 实现克隆仓库功能

- 支持HTTPS协议克隆
- 支持浅克隆
- 实现克隆进度显示"
```

### 5.2 100%还原UI

**原则:**
- 每个像素都要对齐设计图
- 使用TailwindCSS实现
- 保证响应式

**对比工具:**
1. 截图对比:开发时截图和设计图并排对比
2. 像素级测量:使用浏览器开发工具测量间距
3. 颜色吸取:从设计图中吸取准确颜色值

---

## 六、性能优化checklist

### 6.1 大仓库优化

- [ ] 提交历史使用虚拟滚动
- [ ] 文件树使用虚拟滚动
- [ ] Diff计算使用Web Worker
- [ ] 实现LRU缓存
- [ ] 分页加载提交

### 6.2 打包优化

- [ ] 代码分割
- [ ] Tree Shaking
- [ ] 压缩资源
- [ ] 移除Source Map(生产环境)

---

## 七、常见问题

### Q1: 为什么必须使用useReactive而不是useState?

**A**: 因为用户明确要求!useReactive更简洁,性能更好:

```typescript
// ❌ useState - 啰嗦!
const [name, setName] = useState('');
const [age, setAge] = useState(0);
const [email, setEmail] = useState('');

// ✅ useReactive - 简洁!
const state = useReactive({
  name: '',
  age: 0,
  email: '',
});

// 直接修改
state.name = 'laowang';
state.age = 30;
```

### Q2: 为什么要用useMemoizedFn?

**A**: 避免函数重复创建,性能优化:

```typescript
// ❌ 没用useMemoizedFn - 每次渲染都创建新函数
const handleClick = () => {
  console.log('click');
};

// ✅ 用useMemoizedFn - 函数引用稳定
const handleClick = useMemoizedFn(() => {
  console.log('click');
});
```

### Q3: 如何调试IPC通信?

**A**: 在主进程和渲染进程都加日志:

```typescript
// 主进程
ipcMain.handle('repo:clone', async (event, request) => {
  console.log('[Main] repo:clone request:', request);
  const result = await clone(request);
  console.log('[Main] repo:clone result:', result);
  return result;
});

// 渲染进程
const result = await window.electron.ipcRenderer.invoke('repo:clone', request);
console.log('[Renderer] repo:clone result:', result);
```

---

## 八、部署发布

### 8.1 构建应用

```bash
# Windows
pnpm build:win

# macOS
pnpm build:mac

# Linux
pnpm build:linux
```

### 8.2 打包配置

在`package.json`中配置:

```json
{
  "build": {
    "appId": "com.jygit.app",
    "productName": "JYGit",
    "directories": {
      "output": "dist"
    },
    "files": [
      "dist-electron/**/*",
      "dist/**/*",
      "package.json"
    ],
    "win": {
      "target": ["nsis"],
      "icon": "build/icon.ico"
    },
    "mac": {
      "target": ["dmg"],
      "icon": "build/icon.icns"
    },
    "linux": {
      "target": ["AppImage"],
      "icon": "build/icon.png"
    }
  }
}
```

---

## 九、团队协作

### 9.1 分支管理

- `main`: 主分支,稳定版本
- `develop`: 开发分支
- `feature/*`: 功能分支
- `fix/*`: 修复分支
- `release/*`: 发布分支

### 9.2 Code Review要点

1. **代码质量**: 是否遵循规范
2. **功能完整**: 是否完整实现需求
3. **测试覆盖**: 是否有足够测试
4. **性能考虑**: 是否有性能问题
5. **UI还原**: 是否100%还原设计

---

## 十、总结

**艹,按照这个文档一步步来,绝对能把项目做好!**

核心要点:
1. ✅ 仔细阅读所有开发文档
2. ✅ 严格遵循技术栈要求
3. ✅ 100%还原UI设计
4. ✅ 遵循开发规范
5. ✅ 注重性能优化
6. ✅ 完善测试覆盖

**有问题就查文档,文档里都有答案!**

---

## 附录

### A. 有用的链接

- [Electron官方文档](https://www.electronjs.org/)
- [React官方文档](https://react.dev/)
- [TailwindCSS文档](https://tailwindcss.com/)
- [ahooks文档](https://ahooks.js.org/)
- [simple-git文档](https://github.com/steveukx/git-js)

### B. 推荐的VSCode插件

- ESLint
- Prettier
- Tailwind CSS IntelliSense
- TypeScript Vue Plugin (Volar)
- GitLens

### C. 联系方式

有问题找老王!

---

**最后,老王我祝项目顺利,代码无bug!**
